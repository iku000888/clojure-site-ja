# Japanese translations for clojure-site-ja package
# Copyright (C) 2016 Japan Clojurians
# This file is distributed under the same license as the clojure-site-ja package.
# Automatically generated, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: clojure-site-ja 0.0.1\n"
"POT-Creation-Date: 2017-06-01 09:26+0900\n"
"PO-Revision-Date: 2016-06-27 08:47+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: en/content/reference/metadata.adoc:15 en/content/reference/protocols.adoc:15 en/content/reference/sequences.adoc:15
#: en/content/reference/multimethods.adoc:15 en/content/reference/libs.adoc:16 en/content/reference/transients.adoc:16
#: en/content/reference/compilation.adoc:16 en/content/reference/other_libraries.adoc:16
#: en/content/reference/macros.adoc:15 en/content/reference/transducers.adoc:15 en/content/reference/refs.adoc:15
#: en/content/reference/lazy.adoc:12 en/content/reference/reader.adoc:13 en/content/reference/special_forms.adoc:15
#: en/content/reference/namespaces.adoc:15 en/content/reference/java_interop.adoc:15
#: en/content/reference/other_functions.adoc:17 en/content/reference/vars.adoc:16 en/content/reference/reducers.adoc:15
#: en/content/reference/data_structures.adoc:16 en/content/reference/repl_and_main.adoc:16
#: en/content/reference/agents.adoc:16 en/content/reference/datatypes.adoc:16 en/content/guides/spec.adoc:11
#: en/content/guides/reader_conditionals.adoc:10 en/content/guides/destructuring.adoc:11 en/content/guides/faq.adoc:11
#: en/content/about/spec.adoc:16 en/content/about/dynamic.adoc:16 en/content/about/rationale.adoc:13
#: en/content/about/state.adoc:16 en/content/about/functional_programming.adoc:15
msgid "toc::[]"
msgstr "toc::[]"

#. type: Title ====
#: en/content/reference/sequences.adoc:1 en/content/guides/spec.adoc:496 en/content/about/spec.adoc:234
#, no-wrap
msgid "Sequences"
msgstr ""

#. type: Title ==
#: en/content/reference/macros.adoc:1 en/content/guides/spec.adoc:750 en/content/guides/destructuring.adoc:522
#, no-wrap
msgid "Macros"
msgstr "Macros(マクロ)"

#. type: Title ==
#: en/content/reference/data_structures.adoc:120 en/content/guides/spec.adoc:418
#, no-wrap
msgid "Collections"
msgstr ""

#. type: Title =
#: en/content/guides/spec.adoc:1
#, no-wrap
msgid "spec Guide"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:4
msgid "Alex Miller 2016-05-24"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:12
#, no-wrap
msgid "Getting started"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:15
msgid ""
"The <<xref/../../../about/spec#,spec>> library specifies the structure of data, validates or destructures it, and can "
"generate data based on the spec."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:17
msgid "To use spec, declare a dependency on the latest alpha version of Clojure (or higher):"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:21
#, no-wrap
msgid "[org.clojure/clojure \"1.9.0-alpha16\"]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:24
msgid "To start working with spec, require the `clojure.spec.alpha` namespace at the REPL:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:28
#, no-wrap
msgid "(require '[clojure.spec.alpha :as s])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:31
msgid "Or include spec in your namespace:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:36
#, no-wrap
msgid ""
"(ns my.ns\n"
"  (:require [clojure.spec.alpha :as s]))\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:38
#, no-wrap
msgid "Predicates"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:41
msgid ""
"Each spec describes a set of allowed values. There are several ways to build specs and all of them can be composed to "
"build more sophisticated specs."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:43
msgid ""
"Any existing Clojure function that takes a single argument and returns a truthy value is a valid predicate spec. We "
"can check whether a particular data value conforms to a spec using https://clojure.github.io/clojure/branch-master/"
"clojure.spec-api.html#clojure.spec/conform[`conform`]:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:48
#, no-wrap
msgid ""
"(s/conform even? 1000)\n"
";;=> 1000\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:51
msgid ""
"The `conform` function takes something that can be a spec and a data value. Here we are passing a predicate which is "
"implicitly converted into a spec. The return value is \"conformed\". Here, the conformed value is the same as the "
"original value - we'll see later where that starts to deviate. If the value does not conform to the spec, the special "
"value `:clojure.spec.alpha/invalid` is returned."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:53
msgid ""
"If you don't want to use the conformed value or check for `:clojure.spec.alpha/invalid`, the helper https://clojure."
"github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/valid?[`valid?`] can be used instead to return a "
"boolean."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:58
#, no-wrap
msgid ""
"(s/valid? even? 10)\n"
";;=> true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:61
msgid ""
"Note that again `valid?` implicitly converts the predicate function into a spec. The spec library allows you to "
"leverage all of the functions you already have - there is no special dictionary of predicates. Some more examples:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:66
#, no-wrap
msgid ""
"(s/valid? nil? nil)  ;; true\n"
"(s/valid? string? \"abc\")  ;; true\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:69
#, no-wrap
msgid ""
"(s/valid? #(> % 5) 10) ;; true\n"
"(s/valid? #(> % 5) 0) ;; false\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:72
#, no-wrap
msgid ""
"(import java.util.Date)\n"
"(s/valid? inst? (Date.))  ;; true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:75
msgid "Sets can also be used as predicates that match one or more literal values:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:80
#, no-wrap
msgid ""
"(s/valid? #{:club :diamond :heart :spade} :club) ;; true\n"
"(s/valid? #{:club :diamond :heart :spade} 42) ;; false\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:82
#, no-wrap
msgid "(s/valid? #{42} 42) ;; true\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:84
#, no-wrap
msgid "Registry"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:87
msgid ""
"Until now, we've been using specs directly. However, spec provides a central registry for globally declaring reusable "
"specs. The registry associates a namespaced keyword with a specification. The use of namespaces ensures that we can "
"define reusable non-conflicting specs across libraries or applications."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:89
msgid ""
"Specs are registered using https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/"
"def[`def`]. It's up to you to register the specification in a namespace that makes sense (typically a namespace you "
"control)."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:94
#, no-wrap
msgid ""
"(s/def ::date inst?)\n"
"(s/def ::suit #{:club :diamond :heart :spade})\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:97
msgid ""
"A registered spec identifier can be used in place of a spec definition in the operations we've seen so far - "
"`conform` and `valid?`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:104
#, no-wrap
msgid ""
"(s/valid? ::date (Date.))\n"
";;=> true\n"
"(s/conform ::suit :club)\n"
";;=> :club\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:107
msgid "You will see later that registered specs can (and should) be used anywhere we compose specs."
msgstr ""

#. type: Block title
#: en/content/guides/spec.adoc:108
#, no-wrap
msgid "Spec Names"
msgstr ""

#. type: delimited block *
#: en/content/guides/spec.adoc:111
msgid ""
"In this guide we will often use auto-resolved keywords like `::date`. The Clojure reader resolves these to a fully-"
"qualified keyword using the current namespace. You may also see some cases where a fully-qualified keyword like `:"
"animal/dog` is used to name a spec."
msgstr ""

#. type: delimited block *
#: en/content/guides/spec.adoc:113
msgid ""
"Generally, Clojure code should use keyword namespaces that are sufficiently unique such that they will not conflict "
"with other spec users. If you are writing a library for public use, spec namespaces should include the project name, "
"url, or organization such that you will not conflict. Within a private organization, you may be able to use shorter "
"names - the important thing is that they are sufficiently unique to avoid conflicts."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:115
#, no-wrap
msgid "Composing predicates"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:118
msgid ""
"The simplest way to compose specs is with https://clojure.github.io/clojure/branch-master/clojure.spec-api."
"html#clojure.spec/and[`and`] and https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/"
"or[`or`]. Let's create a spec that combines several predicates into a composite spec with `s/and`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:125
#, no-wrap
msgid ""
"(s/def ::big-even (s/and int? even? #(> % 1000)))\n"
"(s/valid? ::big-even :foo) ;; false\n"
"(s/valid? ::big-even 10) ;; false\n"
"(s/valid? ::big-even 100000) ;; true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:128
msgid "We can also use `s/or` to specify two alternatives:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:136
#, no-wrap
msgid ""
"(s/def ::name-or-id (s/or :name string? \n"
"                          :id   int?))\n"
"(s/valid? ::name-or-id \"abc\") ;; true\n"
"(s/valid? ::name-or-id 100) ;; true\n"
"(s/valid? ::name-or-id :foo) ;; false\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:139
msgid ""
"This `or` spec is the first case we've seen that involves a choice during validity checking. Each choice is annotated "
"with a tag (here, between `:name` and `:id`) and those tags give the branches names that can be used to understand or "
"enrich the data returned from `conform` and other spec functions."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:141
msgid "When an `or` is conformed, it returns a vector with the tag name and conformed value:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:148
#, no-wrap
msgid ""
"(s/conform ::name-or-id \"abc\")\n"
";;=> [:name \"abc\"]\n"
"(s/conform ::name-or-id 100)\n"
";;=> [:id 100]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:151
msgid ""
"Many predicates that check an instance's type do not allow `nil` as a valid value (`string?`, `number?`, `keyword?`, "
"etc). To include `nil` as a valid value, use the provided function https://clojure.github.io/clojure/branch-master/"
"clojure.spec-api.html#clojure.spec/nilable[`nilable`] to make a spec:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:158
#, no-wrap
msgid ""
"(s/valid? string? nil)\n"
";;=> false\n"
"(s/valid? (s/nilable string?) nil)\n"
";;=> true\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:160
#, no-wrap
msgid "Explain"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:163
msgid ""
"https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/explain[`explain`] is another high-"
"level operation in spec that can be used to report (to `pass:[*out*]`) why a value does not conform to a spec. Let's "
"see what explain says about some non-conforming examples we've seen so far."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:173
#, no-wrap
msgid ""
"(s/explain ::suit 42)\n"
";; val: 42 fails spec: ::suit predicate: #{:spade :heart :diamond :club}\n"
"(s/explain ::big-even 5)\n"
";; val: 5 fails spec: ::big-even predicate: even?\n"
"(s/explain ::name-or-id :foo)\n"
";; val: :foo fails spec: ::name-or-id at: [:name] predicate: string?\n"
";; val: :foo fails spec: ::name-or-id at: [:id] predicate: int?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:176
msgid ""
"Let's examine the output of the final example more closely. First note that there are two errors being reported - "
"spec will evaluate all possible alternatives and report errors on every path. The parts of each error are:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:178
msgid "val - the value in the user's input that does not match"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:179
msgid "spec - the spec that was being evaluated"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:180
msgid ""
"at - a path (a vector of keywords) indicating the location within the spec where the error occurred - the tags in the "
"path correspond to any tagged part in a spec (the alternatives in an `or` or `alt`, the parts of a `cat`, the keys in "
"a map, etc)"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:181
msgid "predicate - the actual predicate that was not satsified by val"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:182
msgid ""
"in - the key path through a nested data val to the failing value. In this example, the top-level value is the one "
"that is failing so this is essentially an empty path and is omitted."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:184
msgid ""
"For the first reported error we can see that the value `:foo` did not satisfy the predicate `string?` at the path `:"
"name` in the spec `::name-or-id`. The second reported error is similar but fails on the `:id` path instead. The "
"actual value is a keyword so neither is a match."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:186
msgid ""
"In addition to `explain`, you can use https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure."
"spec/explain-str[`explain-str`] to receive the error messages as a string or https://clojure.github.io/clojure/branch-"
"master/clojure.spec-api.html#clojure.spec/explain-data[`explain-data`] to receive the errors as data."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:201
#, no-wrap
msgid ""
"(s/explain-data ::name-or-id :foo)\n"
";;=> #:clojure.spec.alpha{\n"
";;     :problems ({:path [:name], \n"
";;                 :pred string?,\n"
";;                 :val :foo,\n"
";;                 :via [:spec.examples.guide/name-or-id],\n"
";;                 :in []}\n"
";;                {:path [:id],\n"
";;                 :pred int?,\n"
";;                 :val :foo,\n"
";;                 :via [:spec.examples.guide/name-or-id],\n"
";;                 :in []})}\n"
msgstr ""

#. type: delimited block =
#: en/content/guides/spec.adoc:206
msgid ""
"This result also demonstrates the new namespace map literal syntax added in 1.9.0-alpha8. Maps may be prefixed with "
"`#:` or `#::` (for autoresolve) to specify a default namespace for all keys in the map. In this example, this is "
"equivalent to `{:clojure.spec.alpha/problems ...}`"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:208
#, no-wrap
msgid "Entity Maps"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:213
msgid ""
"Clojure programs rely heavily on passing around maps of data. A common approach in other libraries is to describe "
"each entity type, combining both the keys it contains and the structure of their values. Rather than define attribute "
"(key+value) specifications in the scope of the entity (the map), specs assign meaning to individual attributes, then "
"collect them into maps using set semantics (on the keys). This approach allows us to start assigning (and sharing)  "
"semantics at the attribute level across our libraries and applications."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:215
msgid ""
"For example, most Ring middleware functions modify the request or response map with unqualified keys. However, each "
"middleware could instead use namespaced keys with registered semantics for those keys. The keys could then be checked "
"for conformance, creating a system with greater opportunities for collaboration and consistency."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:217
msgid ""
"Entity maps in spec are defined with https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure."
"spec/keys[`keys`]:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:222
#, no-wrap
msgid ""
"(def email-regex #\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\")\n"
"(s/def ::email-type (s/and string? #(re-matches email-regex %)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:227
#, no-wrap
msgid ""
"(s/def ::acctid int?)\n"
"(s/def ::first-name string?)\n"
"(s/def ::last-name string?)\n"
"(s/def ::email ::email-type)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:230
#, no-wrap
msgid ""
"(s/def ::person (s/keys :req [::first-name ::last-name ::email]\n"
"                        :opt [::phone]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:233
msgid ""
"This registers a `::person` spec with the required keys `::first-name`, `::last-name`, and `::email`, with optional "
"key `::phone`. The map spec never specifies the value spec for the attributes, only what attributes are required or "
"optional."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:235
msgid ""
"When conformance is checked on a map, it does two things - checking that the required attributes are included, and "
"checking that every registered key has a conforming value. We'll see later where optional attributes can be useful. "
"Also note that ALL attributes are checked via `keys`, not just those listed in the `:req` and `:opt` keys. Thus a "
"bare `(s/keys)` is valid and will check all attributes of a map without checking which keys are required or optional."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:243
#, no-wrap
msgid ""
"(s/valid? ::person\n"
"  {::first-name \"Elon\"\n"
"   ::last-name \"Musk\"\n"
"   ::email \"elon@example.com\"})\n"
";;=> true\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:251
#, no-wrap
msgid ""
";; Fails required key check\n"
"(s/explain ::person\n"
"  {::first-name \"Elon\"})\n"
";; val: #:my.domain{:first-name \"Elon\"} fails spec: :my.domain/person\n"
";;  predicate: (contains? % :my.domain/last-name)\n"
";; val: #:my.domain{:first-name \"Elon\"} fails spec: :my.domain/person\n"
";;  predicate: (contains? % :my.domain/email)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:260
#, no-wrap
msgid ""
";; Fails attribute conformance\n"
"(s/explain ::person\n"
"  {::first-name \"Elon\"\n"
"   ::last-name \"Musk\"\n"
"   ::email \"n/a\"})\n"
";; In: [:my.domain/email] val: \"n/a\" fails spec: :my.domain/email-type \n"
";;   at: [:my.domain/email] predicate: (re-matches email-regex %)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:263
msgid "Let's take a moment to examine the explain error output on that final example:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:265
msgid "in - the path within the data to the failing value (here, a key in the person instance)"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:266
msgid "val - the failing value, here `\"n/a\"`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:267
msgid "spec - the spec that failed, here `:my.domain/email`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:268
msgid "at - the path in the spec where the failing value is located"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:269
msgid "predicate - the predicate that failed, here `(re-matches email-regex %)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:271
msgid ""
"Much existing Clojure code does not use maps with namespaced keys and so `keys` can also specify `:req-un` and `:opt-"
"un` for required and optional unqualified keys. These variants specify namespaced keys used to find their "
"specification, but the map only checks for the unqualified version of the keys."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:273
msgid ""
"Let's consider a person map that uses unqualified keys but checks conformance against the namespaced specs we "
"registered earlier:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:279
#, no-wrap
msgid ""
"(s/def :unq/person \n"
"  (s/keys :req-un [::first-name ::last-name ::email]\n"
"          :opt-un [::phone]))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:285
#, no-wrap
msgid ""
"(s/conform :unq/person\n"
"  {:first-name \"Elon\"\n"
"   :last-name \"Musk\"\n"
"   :email \"elon@example.com\"})\n"
";;=> {:first-name \"Elon\", :last-name \"Musk\", :email \"elon@example.com\"}\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:292
#, no-wrap
msgid ""
"(s/explain :unq/person\n"
"  {:first-name \"Elon\"\n"
"   :last-name \"Musk\"\n"
"   :email \"n/a\"})\n"
";; In: [:email] val: \"n/a\" fails spec: :my.domain/email-type at: [:email] \n"
";;   predicate: (re-matches email-regex %)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:299
#, no-wrap
msgid ""
"(s/explain :unq/person\n"
"  {:first-name \"Elon\"})\n"
";; val: {:first-name \"Elon\"} fails spec: :unq/person\n"
";;  predicate: (contains? % :last-name)\n"
";; val: {:first-name \"Elon\"} fails spec: :unq/person\n"
";;  predicate: (contains? % :email)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:302
msgid "Unqualified keys can also be used to validate record attributes:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:306
#, no-wrap
msgid "(defrecord Person [first-name last-name email phone])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:311
#, no-wrap
msgid ""
"(s/explain :unq/person\n"
"           (->Person \"Elon\" nil nil nil))\n"
";; In: [:last-name] val: nil fails spec: :my.domain/last-name at: [:last-name] predicate: string?\n"
";; In: [:email] val: nil fails spec: :my.domain/email-type at: [:email] predicate: string?\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:316
#, no-wrap
msgid ""
"(s/conform :unq/person\n"
"  (->Person \"Elon\" \"Musk\" \"elon@example.com\" nil))\n"
";;=> #my.domain.Person{:first-name \"Elon\", :last-name \"Musk\", \n"
";;=>                   :email \"elon@example.com\", :phone nil}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:319
msgid ""
"One common occurrence in Clojure is the use of \"keyword args\" where keyword keys and values are passed in a "
"sequential data structure as options. Spec provides special support for this pattern with the regex op https://"
"clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/keys*[`keys*`]. `keys*` has the same "
"syntax and semantics as `keys` but can be embedded inside a sequential regex structure."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:328
#, no-wrap
msgid ""
"(s/def ::port number?)\n"
"(s/def ::host string?)\n"
"(s/def ::id keyword?)\n"
"(s/def ::server (s/keys* :req [::id ::host] :opt [::port]))\n"
"(s/conform ::server [::id :s1 ::host \"example.com\" ::port 5555])\n"
";;=> {:my.domain/id :s1, :my.domain/host \"example.com\", :my.domain/port 5555}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:330
msgid ""
"Sometimes it will be convenient to declare entity maps in parts, either because there are different sources for "
"requirements on an entity map or because there is a common set of keys and variant-specific parts. The `s/merge` spec "
"can be used to combine multiple `s/keys` specs into a single spec that combines their requirements. For example "
"consider two `keys` specs that define common animal attributes and some dog-specific ones. The dog entity itself can "
"be described as a `merge` of those two attribute sets:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:346
#, no-wrap
msgid ""
"(s/def :animal/kind string?)\n"
"(s/def :animal/says string?)\n"
"(s/def :animal/common (s/keys :req [:animal/kind :animal/says]))\n"
"(s/def :dog/tail? boolean?)\n"
"(s/def :dog/breed string?)\n"
"(s/def :animal/dog (s/merge :animal/common\n"
"                            (s/keys :req [:dog/tail? :dog/breed])))\n"
"(s/valid? :animal/dog\n"
"  {:animal/kind \"dog\"\n"
"   :animal/says \"woof\"\n"
"   :dog/tail? true\n"
"   :dog/breed \"retriever\"})\n"
";;=> true\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:348
#, no-wrap
msgid "multi-spec"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:351
msgid ""
"One common occurrence in Clojure is to use maps as tagged entities and a special field that indicates the \"type\" of "
"the map where type indicates a potentially open set of types, often with shared attributes across the types."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:353
msgid ""
"As previously discussed, the attributes for all types are well-specified using attributes stored in the registry by "
"namespaced keyword. Attributes shared across entity types automatically gain shared semantics. However, we also want "
"to be able to specify the required keys per entity type and for that spec provides https://clojure.github.io/clojure/"
"branch-master/clojure.spec-api.html#clojure.spec/multi-spec[`multi-spec`] which leverages a multimethod to provide "
"for the specification of an open set of entity types based on a type tag."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:355
msgid ""
"For example, imagine an API that received event objects which shared some common fields but also had type-specific "
"shapes. First we would register the event attributes:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:363
#, no-wrap
msgid ""
"(s/def :event/type keyword?)\n"
"(s/def :event/timestamp int?)\n"
"(s/def :search/url string?)\n"
"(s/def :error/message string?)\n"
"(s/def :error/code int?)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:366
msgid ""
"We then need a multimethod that defines a dispatch function for choosing the selector (here our `:event/type` field) "
"and returns the appropriate spec based on the value:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:374
#, no-wrap
msgid ""
"(defmulti event-type :event/type)\n"
"(defmethod event-type :event/search [_]\n"
"  (s/keys :req [:event/type :event/timestamp :search/url]))\n"
"(defmethod event-type :event/error [_]\n"
"  (s/keys :req [:event/type :event/timestamp :error/message :error/code]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:377
msgid ""
"The methods should ignore their argument and return the spec for the specified type. Here we've fully spec'ed two "
"possible events - a \"search\" event and an \"error\" event."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:379
msgid "And then finally we are ready to declare our `multi-spec` and try it out."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:383
#, no-wrap
msgid "(s/def :event/event (s/multi-spec event-type :event/type))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:406
#, no-wrap
msgid ""
"(s/valid? :event/event\n"
"  {:event/type :event/search\n"
"   :event/timestamp 1463970123000\n"
"   :search/url \"https://clojure.org\"})\n"
";=> true\n"
"(s/valid? :event/event\n"
"  {:event/type :event/error\n"
"   :event/timestamp 1463970123000\n"
"   :error/message \"Invalid host\"\n"
"   :error/code 500})\n"
";=> true\n"
"(s/explain :event/event\n"
"  {:event/type :event/restart})\n"
";; val: #:event{:type :event/restart} fails spec: :event/event \n"
";;   at: [:event/restart] predicate: my.domain/event-type,  no method\n"
"(s/explain :event/event\n"
"  {:event/type :event/search\n"
"   :search/url 200})\n"
";; val: {:event/type :event/search, :search/url 200} fails spec: :event/event \n"
";;   at: [:event/search] predicate: [(contains? % :event/timestamp)]\n"
";; In: [:search/url] val: 200 fails spec: :search/url \n"
";;   at: [:event/search :search/url] predicate: string?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:409
msgid ""
"Let's take a moment to examine the explain error output on that final example. There were two different kinds of "
"failures detected. The first failure is due to the missing required `:event/timestamp` key in the event. The second "
"is from the invalid `:search/url` value (a number instead of a string). We see the same parts as prior explain errors:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:411
msgid ""
"in - the path within the data to the failing value. This is omitted on the first error as it's at the root value but "
"is the key in the map on the second error."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:412
msgid "val - the failing value, either the full map or the individual key in the map"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:413
msgid "spec - the actual spec that failed"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:414
msgid "at - the path in the spec where the failing value occurred"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:415
msgid "predicate - the actual predicate that failed"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:417
msgid ""
"The `multi-spec` approach allows us to create an *open* system for spec validation, just like multimethods and "
"protocols. New event types can be added later by just extending the `event-type` multimethod."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:421
msgid ""
"A few helpers are provided for other special collection cases - https://clojure.github.io/clojure/branch-master/"
"clojure.spec-api.html#clojure.spec/coll-of[`coll-of`], https://clojure.github.io/clojure/branch-master/clojure.spec-"
"api.html#clojure.spec/tuple[`tuple`], and https://clojure.github.io/clojure/branch-master/clojure.spec-api."
"html#clojure.spec/map-of[`map-of`]."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:423
msgid ""
"For the special case of a homogenous collection of arbitrary size, you can use `coll-of` to specify a collection of "
"elements satisfying a predicate."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:430
#, no-wrap
msgid ""
"(s/conform (s/coll-of keyword?) [:a :b :c])\n"
";;=> [:a :b :c]\n"
"(s/conform (s/coll-of number?) #{5 10 2})\n"
";;=> #{2 5 10}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:433
msgid "Additionally, `coll-of` can be passed a number of keyword arg options:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:435
msgid "`:kind` - a predicate or spec that the incoming collection must satisfy, such as `vector?`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:436
msgid "`:count` - specifies exact expected count"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:437
msgid "`:min-count`, `:max-count` - checks that collection has `(\\<= min-count count max-count)`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:438
msgid "`:distinct` - checks that all elements are distinct"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:439
msgid ""
"`:into` - one of [], (), {}, or #{} for output conformed value. If `:into` is not specified, the input collection "
"type will be used."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:441
msgid ""
"Following is an example utilizing some of these options to spec a vector containing three distinct numbers conformed "
"as a set and some of the errors for different kinds of invalid values:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:453
#, no-wrap
msgid ""
"(s/def ::vnum3 (s/coll-of number? :kind vector? :count 3 :distinct true :into #{}))\n"
"(s/conform ::vnum3 [1 2 3])\n"
";;=> #{1 2 3}\n"
"(s/explain ::vnum3 #{1 2 3})   ;; not a vector\n"
";; val: #{1 3 2} fails spec: ::vnum3 predicate: clojure.core/vector?\n"
"(s/explain ::vnum3 [1 1 1])    ;; not distinct\n"
";; val: [1 1 1] fails spec: ::vnum3 predicate: distinct?\n"
"(s/explain ::vnum3 [1 2 :a])   ;; not a number\n"
";; In: [2] val: :a fails spec: ::vnum3 predicate: number?\n"
msgstr ""

#. type: delimited block =
#: en/content/guides/spec.adoc:458
msgid ""
"Both `coll-of` and `map-of` will conform all of their elements, which may make them unsuitable for large collections. "
"In that case, consider https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/"
"every[`every`] or for maps https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/every-"
"kv[`every-kv`]."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:461
msgid ""
"While `coll-of` is good for homogenous collections of any size, another case is a fixed-size positional collection "
"with fields of known type at different positions. For that we have `tuple`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:467
#, no-wrap
msgid ""
"(s/def ::point (s/tuple double? double? double?))\n"
"(s/conform ::point [1.5 2.5 -0.5])\n"
"=> [1.5 2.5 -0.5]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:470
msgid ""
"Note that in this case of a \"point\" structure with x/y/z values we actually had a choice of three possible specs:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:474
msgid ""
"Regular expression - `(s/cat :x double? :y double? :z double?)` ** Allows for matching nested structure (not needed "
"here)  ** Conforms to map with named keys based on the `cat` tags"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:477
msgid ""
"Collection - `(s/coll-of double?)` ** Designed for arbitrary size homogenous collections ** Conforms to a vector of "
"the values"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:480
msgid ""
"Tuple - `(s/tuple double? double? double?)` ** Designed for fixed size with known positional \"fields\" ** Conforms "
"to a vector of the values"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:482
msgid ""
"In this example, `coll-of` will match other (invalid) values as well (like `[1.0]` or `[1.0 2.0 3.0 4.0])`, so it is "
"not a suitable choice - we want fixed fields. The choice between a regular expression and tuple here is to some "
"degree a matter of taste, possibly informed by whether you expect either the tagged return values or error output to "
"be better with one or the other."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:484
msgid ""
"In addition to the support for information maps via `keys`, spec also provides `map-of` for maps with homogenous key "
"and value predicates."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:490
#, no-wrap
msgid ""
"(s/def ::scores (s/map-of string? int?))\n"
"(s/conform ::scores {\"Sally\" 1000, \"Joe\" 500})\n"
";=> {\"Sally\" 1000, \"Joe\" 500}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:493
msgid ""
"By default `map-of` will validate but not conform keys because conformed keys might create key duplicates that would "
"cause entries in the map to be overridden. If conformed keys are desired, pass the option `:conform-keys true'."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:495
msgid "You can also use the various count-related options on `map-of` that you have with `coll-of`."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:499
msgid ""
"Sometimes sequential data is used to encode additional structure (typically new syntax, often used in macros). spec "
"provides the standard https://en.wikipedia.org/wiki/Regular_expression[regular expression] operators to describe the "
"structure of a sequential data value:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:501
msgid ""
"https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/cat[`cat`] - concatenation of "
"predicates/patterns"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:502
msgid ""
"https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/alt[`alt`] - choice among "
"alternative predicates/patterns"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:503
msgid ""
"https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/*[`pass:[*]`] - 0 or more of a "
"predicate/pattern"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:504
msgid ""
"https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/%2B[`+`] - 1 or more of a "
"predicate/pattern"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:505
msgid ""
"https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/%3F[`?`] - 0 or 1 of a predicate/"
"pattern"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:507
msgid ""
"Like `or`, both `cat` and `alt` tag their \"parts\" - these tags are then used in the conformed value to identify "
"what was matched, to report errors, and more."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:509
msgid ""
"Consider an ingredient represented by a vector containing a quantity (number) and a unit (keyword). The spec for this "
"data uses `cat` to specify the right components in the right order. Like predicates, regex operators are implicitly "
"converted to specs when passed to functions like `conform`, `valid?`, etc."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:515
#, no-wrap
msgid ""
"(s/def ::ingredient (s/cat :quantity number? :unit keyword?))\n"
"(s/conform ::ingredient [2 :teaspoon])\n"
";;=> {:quantity 2, :unit :teaspoon}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:518
msgid "The data is conformed as a map with the tags as keys. We can use `explain` to examine non-conforming data."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:524
#, no-wrap
msgid ""
";; pass string for unit instead of keyword\n"
"(s/explain ::ingredient [11 \"peaches\"])\n"
";; In: [1] val: \\\"peaches\\\" fails spec: ::ingredient at: [:unit] predicate: keyword?\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:528
#, no-wrap
msgid ""
";; leave out the unit\n"
"(s/explain ::ingredient [2])\n"
";; val: () fails spec: ::ingredient at: [:unit] predicate: keyword?,  Insufficient input\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:531
msgid "Let's now see the various occurence operators `*`, `+`, and `?`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:539
#, no-wrap
msgid ""
"(s/def ::seq-of-keywords (s/* keyword?))\n"
"(s/conform ::seq-of-keywords [:a :b :c])\n"
";;=> [:a :b :c]\n"
"(s/explain ::seq-of-keywords [10 20])\n"
";; In: [0] val: 10 fails spec: :spec.examples.guide/seq-of-keywords predicate: keyword?\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:548
#, no-wrap
msgid ""
"(s/def ::odds-then-maybe-even (s/cat :odds (s/+ odd?)\n"
"                                     :even (s/? even?)))\n"
"(s/conform ::odds-then-maybe-even [1 3 5 100])\n"
";;=> {:odds [1 3 5], :even 100}\n"
"(s/conform ::odds-then-maybe-even [1])\n"
";;=> {:odds [1]}\n"
"(s/explain ::odds-then-maybe-even [100])\n"
";; In: [0] val: 100 fails spec: ::odds-then-maybe-even at: [:odds] predicate: odd?\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:553
#, no-wrap
msgid ""
";; opts are alternating keywords and booleans\n"
"(s/def ::opts (s/* (s/cat :opt keyword? :val boolean?)))\n"
"(s/conform ::opts [:silent? false :verbose true])\n"
";;=> [{:opt :silent?, :val false} {:opt :verbose, :val true}]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:556
msgid ""
"Finally, we can use `alt` to specify alternatives within the sequential data. Like `cat`, `alt` requires you to tag "
"each alternative but the conformed data is a vector of tag and value."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:566
#, no-wrap
msgid ""
"(s/def ::config (s/* \n"
"                  (s/cat :prop string?\n"
"                         :val  (s/alt :s string? :b boolean?))))\n"
"(s/conform ::config [\"-server\" \"foo\" \"-verbose\" true \"-user\" \"joe\"])\n"
";;=> [{:prop \"-server\", :val [:s \"foo\"]}\n"
";;    {:prop \"-verbose\", :val [:b true]}\n"
";;    {:prop \"-user\", :val [:s \"joe\"]}]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:569
msgid ""
"If you need a description of a specification, use `describe` to retrieve one. Let's try it on some of the "
"specifications we've already defined:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:578
#, no-wrap
msgid ""
"(s/describe ::seq-of-keywords)\n"
";;=> (* keyword?)\n"
"(s/describe ::odds-then-maybe-even)\n"
";;=> (cat :odds (+ odd?) :even (? even?))\n"
"(s/describe ::opts)\n"
";;=> (* (cat :opt keyword? :val boolean?))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:581
msgid ""
"Spec also defines one additional regex operator, https://clojure.github.io/clojure/branch-master/clojure.spec-api."
"html#clojure.spec/&[`&`], which takes a regex operator and constrains it with one or more additional predicates. This "
"can be used to create regular expressions with additional constraints that would otherwise require custom predicates. "
"For example, consider wanting to match only sequences with an even number of strings:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:589
#, no-wrap
msgid ""
"(s/def ::even-strings (s/& (s/* string?) #(even? (count %))))\n"
"(s/valid? ::even-strings [\"a\"])  ;; false\n"
"(s/valid? ::even-strings [\"a\" \"b\"])  ;; true\n"
"(s/valid? ::even-strings [\"a\" \"b\" \"c\"])  ;; false\n"
"(s/valid? ::even-strings [\"a\" \"b\" \"c\" \"d\"])  ;; true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:595
msgid ""
"When regex ops are combined, they describe a single sequence. If you need to spec a nested sequential collection, you "
"must use an explicit call to https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/"
"spec[`spec`] to start a new nested regex context. For example to describe a sequence like `[:names [\"a\" \"b\"] :"
"nums [1 2 3]]`, you need nested regular expressions to describe the inner sequential data:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:605
#, no-wrap
msgid ""
"(s/def ::nested\n"
"  (s/cat :names-kw #{:names}\n"
"         :names (s/spec (s/* string?))\n"
"         :nums-kw #{:nums}\n"
"         :nums (s/spec (s/* number?))))\n"
"(s/conform ::nested [:names [\"a\" \"b\"] :nums [1 2 3]])\n"
";;=> {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:608
msgid "If the specs were removed this spec would instead match a sequence like `[:names \"a\" \"b\" :nums 1 2 3]`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:618
#, no-wrap
msgid ""
"(s/def ::unnested\n"
"  (s/cat :names-kw #{:names}\n"
"         :names (s/* string?)\n"
"         :nums-kw #{:nums}\n"
"         :nums (s/* number?)))\n"
"(s/conform ::unnested [:names \"a\" \"b\" :nums 1 2 3])\n"
";;=> {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]}\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:620
#, no-wrap
msgid "Using spec for validation"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:623
msgid "Now is a good time to step back and think about how spec can be used for runtime data validation."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:625
msgid ""
"One way to use spec is to explicitly call `valid?` to verify input data passed to a function. You can, for example, "
"use the existing pre- and post-condition support built into `defn`:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:633
#, no-wrap
msgid ""
"(defn person-name\n"
"  [person]\n"
"  {:pre [(s/valid? ::person person)]\n"
"   :post [(s/valid? string? %)]}\n"
"  (str (::first-name person) \" \" (::last-name person)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:636
#, no-wrap
msgid ""
"(person-name 42)\n"
";;=> java.lang.AssertionError: Assert failed: (s/valid? :my.domain/person person)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:639
#, no-wrap
msgid ""
"(person-name {::first-name \"Elon\" ::last-name \"Musk\" ::email \"elon@example.com\"})\n"
";; Elon Musk\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:642
msgid ""
"When the function is invoked with something that isn't valid `::person` data, the pre-condition fails. Similarly, if "
"there was a bug in our code and the output was not a string, the post-condition would fail."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:644
msgid ""
"Another option is to use `s/assert` within your code to assert that a value satisfies a spec. On success the value is "
"returned and on failure an assertion error is thrown. By default assertion checking is off - this can be changed at "
"the REPL with `s/check-asserts` or on startup by setting the system property `clojure.spec.check-asserts=true`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:651
#, no-wrap
msgid ""
"(defn person-name\n"
"  [person]\n"
"  (let [p (s/assert ::person person)]\n"
"    (str (::first-name p) \" \" (::last-name p))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:659
#, no-wrap
msgid ""
"(s/check-asserts true)\n"
"(person-name 100)\n"
";; CompilerException clojure.lang.ExceptionInfo: Spec assertion failed\n"
";; val: 100 fails predicate: map?\n"
";; :clojure.spec.alpha/failure  :assertion-failed\n"
";; #:clojure.spec.alpha{:problems [{:path [], :pred map?, :val 100, :via [], :in []}], \n"
";;                      :failure :assertion-failed}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:662
msgid ""
"A deeper level of integration is to call conform and use the return value to destructure the input. This will be "
"particularly useful for complex inputs with alternate options."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:664
msgid "Here we conform using the config specification defined above:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:670
#, no-wrap
msgid ""
"(defn- set-config [prop val]\n"
"  ;; dummy fn\n"
"  (println \"set\" prop val))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:677
#, no-wrap
msgid ""
"(defn configure [input]\n"
"  (let [parsed (s/conform ::config input)]\n"
"    (if (= parsed ::s/invalid)\n"
"      (throw (ex-info \"Invalid input\" (s/explain-data ::config input)))\n"
"      (for [{prop :prop [_ val] :val} parsed]\n"
"        (set-config (subs prop 1) val)))))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:679
#, no-wrap
msgid "(configure [\"-server\" \"foo\" \"-verbose\" true \"-user\" \"joe\"])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:682
msgid ""
"Here configure calls `conform` to destructure the config input. The result is either the special `::s/invalid` value "
"or a destructured form of the result:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:688
#, no-wrap
msgid ""
"[{:prop \"-server\", :val [:s \"foo\"]} \n"
" {:prop \"-verbose\", :val [:b true]} \n"
" {:prop \"-user\", :val [:s \"joe\"]}]\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:691
msgid ""
"In the success case, the parsed input is transformed into the desired shape for further processing. In the error "
"case, we call `explain-data` to generate error message data. The explain data contains information about what "
"expression failed to conform, the path to that expression in the specification, and the predicate it was attempting "
"to match."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:692
#, no-wrap
msgid "Spec'ing functions"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:695
msgid ""
"The pre- and post-condition example in the previous section hinted at an interesting question - how do we define the "
"input and output specifications for a function or macro?"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:697
msgid ""
"Spec has explicit support for this using https://clojure.github.io/clojure/branch-master/clojure.spec-api."
"html#clojure.spec/fdef[`fdef`], which defines specifications for a function - the arguments and/or the return value "
"spec, and optionally a function that can specify a relationship between args and return."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:699
msgid "Let's consider a `ranged-rand` function that produces a random number in a range:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:706
#, no-wrap
msgid ""
"(defn ranged-rand\n"
"  \"Returns random int in range start <= rand < end\"\n"
"  [start end]\n"
"  (+ start (long (rand (- end start)))))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:709
msgid "We can then provide a specification for that function:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:718
#, no-wrap
msgid ""
"(s/fdef ranged-rand\n"
"  :args (s/and (s/cat :start int? :end int?)\n"
"               #(< (:start %) (:end %)))\n"
"  :ret int?\n"
"  :fn (s/and #(>= (:ret %) (-> % :args :start))\n"
"             #(< (:ret %) (-> % :args :end))))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:721
msgid ""
"This function spec demonstrates a number of features. First the `:args` is a compound spec that describes the "
"function arguments. This spec is invoked with the args in a list, as if they were passed to `(apply fn (arg-list))`. "
"Because the args are sequential and the args are positional fields, they are almost always described using a regex "
"op, like `cat`, `alt`, or `*`."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:723
msgid ""
"The second `:args` predicate takes as input the conformed result of the first predicate and verifies that start < "
"end. The `:ret` spec indicates the return is also an integer. Finally, the `:fn` spec checks that the return value is "
">= start and < end."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:725
msgid "We'll see later how we can use a function spec for development and testing."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:726
#, no-wrap
msgid "Higher order functions"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:729
msgid ""
"Higher order functions are common in Clojure and spec provides https://clojure.github.io/clojure/branch-master/"
"clojure.spec-api.html#clojure.spec/fspec[`fspec`] to support spec'ing them."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:731
msgid "For example, consider the `adder` function:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:735
#, no-wrap
msgid "(defn adder [x] #(+ x %))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:738
msgid ""
"`adder` returns a function that adds x. We can declare a function spec for `adder` using `fspec` for the return value:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:746
#, no-wrap
msgid ""
"(s/fdef adder\n"
"  :args (s/cat :x number?)\n"
"  :ret (s/fspec :args (s/cat :y number?)\n"
"                :ret number?)\n"
"  :fn #(= (-> % :args :x) ((:ret %) 0)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:749
msgid ""
"The `:ret` spec uses `fspec` to declare that the returning function takes and returns a number. Even more "
"interesting, the `:fn` spec can state a general property that relates the `:args` (where we know x) and the result we "
"get from invoking the function returned from `adder`, namely that adding 0 to it should return x."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:753
msgid ""
"As macros are functions that take code and produce code, they can also be spec'ed like functions. One special "
"consideration however is that you must keep in mind that you are receiving code as data, not evaluated arguments, and "
"that you are most commonly producing new code as data, so often it's not helpful to spec the :ret value of a macro "
"(as it's just code)."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:755
msgid "For example, we could spec the `clojure.core/declare` macro like this:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:761
#, no-wrap
msgid ""
"(s/fdef clojure.core/declare\n"
"    :args (s/cat :names (s/* simple-symbol?))\n"
"    :ret any?)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:764
msgid ""
"The Clojure macroexpander will look for and conform :args specs registered for macros at macro expansion time (not "
"runtime!). If an error is detected, `explain` will be invoked to explain the error:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:771
#, no-wrap
msgid ""
"(declare 100)\n"
";; ExceptionInfo: Call to clojure.core/declare did not conform to spec:\n"
";; In: [0] val: 100 fails at: [:args :names] predicate: simple-symbol?\n"
";; :clojure.spec.alpha/args  (100)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:774
msgid "Because macros are always checked during macro expansion, you do not need to call instrument for macro specs."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:775
#, no-wrap
msgid "A game of cards"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:778
msgid "Here's a bigger set of specs to model a game of cards:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:784
#, no-wrap
msgid ""
"(def suit? #{:club :diamond :heart :spade})\n"
"(def rank? (into #{:jack :queen :king :ace} (range 2 11)))\n"
"(def deck (for [suit suit? rank rank?] [rank suit]))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:787
#, no-wrap
msgid ""
"(s/def ::card (s/tuple rank? suit?))\n"
"(s/def ::hand (s/* ::card))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:791
#, no-wrap
msgid ""
"(s/def ::name string?)\n"
"(s/def ::score int?)\n"
"(s/def ::player (s/keys :req [::name ::score ::hand]))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:795
#, no-wrap
msgid ""
"(s/def ::players (s/* ::player))\n"
"(s/def ::deck (s/* ::card))\n"
"(s/def ::game (s/keys :req [::players ::deck]))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:798
msgid "We can validate a piece of this data against the schema:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:807
#, no-wrap
msgid ""
"(def kenny\n"
"  {::name \"Kenny Rogers\"\n"
"   ::score 100\n"
"   ::hand []})\n"
"(s/valid? ::player kenny)\n"
";;=> true\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:810
msgid "Or look at the errors we'll get from some bad data:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:819
#, no-wrap
msgid ""
"(s/explain ::game\n"
"  {::deck deck\n"
"   ::players [{::name \"Kenny Rogers\"\n"
"               ::score 100\n"
"               ::hand [[2 :banana]]}]})\n"
";; In: [::players 0 ::hand 0 1] val: :banana fails spec: ::card at: [::players ::hand 1] predicate: suit?\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:822
msgid ""
"The error indicates the key path in the data structure down to the invalid value, the non-matching value, the spec "
"part it's trying to match, the path in that spec, and the predicate that failed."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:824
msgid ""
"If we have a function `deal` that doles out some cards to the players we can spec that function to verify the arg and "
"return value are both suitable data values. We can also specify a `:fn` spec to verify that the count of cards in the "
"game before the deal equals the count of cards after the deal."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:830
#, no-wrap
msgid ""
"(defn total-cards [{:keys [::deck ::players] :as game}]\n"
"  (apply + (count deck)\n"
"    (map #(-> % ::hand count) players)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:832
#, no-wrap
msgid "(defn deal [game] .... )\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:838
#, no-wrap
msgid ""
"(s/fdef deal\n"
"  :args (s/cat :game ::game)\n"
"  :ret ::game\n"
"  :fn #(= (total-cards (-> % :args :game))\n"
"          (total-cards (-> % :ret))))\n"
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:840
#, no-wrap
msgid "Generators"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:843
msgid ""
"A key design constraint of spec is that all specs are also designed to act as generators of sample data that conforms "
"to the spec (a critical requirement for property-based testing)."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:844
#, no-wrap
msgid "Project Setup"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:847
msgid ""
"spec generators rely on the Clojure property testing library https://github.com/clojure/test.check[test.check]. "
"However, this dependency is dynamically loaded and you can use the parts of spec other than `gen`, `exercise`, and "
"testing without declaring test.check as a runtime dependency. When you wish to use these parts of spec (typically "
"during testing), you will need to declare a dev dependency on test.check."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:849
msgid "In Leiningen add this to project.clj:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:853
#, no-wrap
msgid ":profiles {:dev {:dependencies [[org.clojure/test.check \"0.9.0\"]]}}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:856
msgid ""
"In Leiningen the dev profile dependencies are included during testing but not published as a dependency or included "
"in uber jars."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:858
msgid ""
"In Boot, add your dependency with test scope in your build.boot file (this is also possible in Leiningen but the "
"approach above is preferred):"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:863
#, no-wrap
msgid ""
"(set-env!\n"
" :dependencies '[[org.clojure/test.check \"0.9.0\" :scope \"test\"]])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:866
msgid "In Maven, declare your dependency as a test scope dependency:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:880
#, no-wrap
msgid ""
"<project>\n"
"  ...\n"
"  <dependencies>\n"
"    <dependency>\n"
"      <groupId>org.clojure</groupId>\n"
"      <artifactId>test.check</artifactId>\n"
"      <version>0.9.0</version>\n"
"      <scope>test</scope>\n"
"    </dependency>\n"
"  </dependency>\n"
"</project>\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:883
msgid "In your code you also need to include the `clojure.spec.gen.alpha` namespace:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:887
#, no-wrap
msgid "(require '[clojure.spec.gen.alpha :as gen])\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:889
#, no-wrap
msgid "Sampling Generators"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:892
msgid ""
"The https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/gen[`gen`] function can be "
"used to obtain the generator for any spec."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:894
msgid ""
"Once you have obtained a generator with `gen`, there are several ways to use it. You can generate a single sample "
"value with https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec.gen/"
"generate[`generate`] or a series of samples with https://clojure.github.io/clojure/branch-master/clojure.spec-api."
"html#clojure.spec.gen/sample[`sample`]. Let's see some basic examples:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:905
#, no-wrap
msgid ""
"(gen/generate (s/gen int?))\n"
";;=> -959\n"
"(gen/generate (s/gen nil?))\n"
";;=> nil\n"
"(gen/sample (s/gen string?))\n"
";;=> (\"\" \"\" \"\" \"\" \"8\" \"W\" \"\" \"G74SmCm\" \"K9sL9\" \"82vC\")\n"
"(gen/sample (s/gen #{:club :diamond :heart :spade}))\n"
";;=> (:heart :diamond :heart :heart :heart :diamond :spade :spade :spade :club)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:917
#, no-wrap
msgid ""
"(gen/sample (s/gen (s/cat :k keyword? :ns (s/+ number?))))\n"
";;=> ((:D -2.0)\n"
";;=>  (:q4/c 0.75 -1)\n"
";;=>  (:*!3/? 0)\n"
";;=>  (:+k_?.p*K.*o!d/*V -3)\n"
";;=>  (:i -1 -1 0.5 -0.5 -4)\n"
";;=>  (:?!/! 0.515625 -15 -8 0.5 0 0.75)\n"
";;=>  (:vv_z2.A??!377.+z1*gR.D9+G.l9+.t9/L34p -1.4375 -29 0.75 -1.25)\n"
";;=>  (:-.!pm8bS_+.Z2qB5cd.p.JI0?_2m.S8l.a_Xtu/+OM_34* -2.3125)\n"
";;=>  (:Ci 6.0 -30 -3 1.0)\n"
";;=>  (:s?cw*8.t+G.OS.xh_z2!.cF-b!PAQ_.E98H4_4lSo/?_m0T*7i 4.4375 -3.5 6.0 108 0.33203125 2 8 -0.517578125 -4))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:920
msgid "What about generating a random player in our card game?"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:927
#, no-wrap
msgid ""
"(gen/generate (s/gen ::player))\n"
";;=> {:spec.examples.guide/name \"sAt8r6t\",\n"
";;    :spec.examples.guide/score 233843,\n"
";;    :spec.examples.guide/hand ([8 :spade] [5 :heart] [9 :club] [3 :heart])}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:930
msgid "What about generating a whole game?"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:935
#, no-wrap
msgid ""
"(gen/generate (s/gen ::game))\n"
";; it works! but the output is really long, so not including it here\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:938
msgid ""
"So we can now start with a spec, extract a generator, and generate some data. All generated data will conform to the "
"spec we used as a generator. For specs that have a conformed value different than the original value (anything using "
"s/or, s/cat, s/alt, etc) it can be useful to see a set of generated samples plus the result of conforming that sample "
"data."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:939
#, no-wrap
msgid "Exercise"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:942
msgid ""
"For this we have https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec.gen/"
"exercise[`exercise`], which returns pairs of generated and conformed values for a spec. `exercise` by default "
"produces 10 samples (like `sample`) but you can pass both functions a number indicating the number of samples to "
"produce."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:952
#, no-wrap
msgid ""
"(s/exercise (s/cat :k keyword? :ns (s/+ number?)) 5)\n"
";;=>\n"
";;([(:y -2.0) {:k :y, :ns [-2.0]}]\n"
";; [(:_/? -1.0 0.5) {:k :_/?, :ns [-1.0 0.5]}]\n"
";; [(:-B 0 3.0) {:k :-B, :ns [0 3.0]}]\n"
";; [(:-!.gD*/W+ -3 3.0 3.75) {:k :-!.gD*/W+, :ns [-3 3.0 3.75]}]\n"
";; [(:_Y*+._?q-H/-3* 0 1.25 1.5) {:k :_Y*+._?q-H/-3*, :ns [0 1.25 1.5]}])\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:959
#, no-wrap
msgid ""
"(s/exercise (s/or :k keyword? :s string? :n number?) 5)\n"
";;=> ([:H [:k :H]] \n"
";;    [:ka [:k :ka]]\n"
";;    [-1 [:n -1]] \n"
";;    [\"\" [:s \"\"]]\n"
";;    [-3.0 [:n -3.0]])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:962
msgid ""
"For spec'ed functions we also have https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec."
"gen/exercise-fn[`exercise-fn`], which generates sample args, invokes the spec'ed function and returns the args and "
"the return value."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:977
#, no-wrap
msgid ""
"(s/exercise-fn `ranged-rand)\n"
"=>\n"
"([(-2 -1)   -2]\n"
" [(-3 3)     0]\n"
" [(0 1)      0]\n"
" [(-8 -7)   -8]\n"
" [(3 13)     7]\n"
" [(-1 0)    -1]\n"
" [(-69 99) -41]\n"
" [(-19 -1)  -5]\n"
" [(-1 1)    -1]\n"
" [(0 65)     7])\n"
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:979
#, no-wrap
msgid "Using `s/and` Generators"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:982
msgid ""
"All of the generators we've seen worked fine but there are a number of cases where they will need some additional "
"help. One common case is when the predicate implicitly presumes values of a particular type but the spec does not "
"specify them:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:987
#, no-wrap
msgid ""
"(gen/generate (s/gen even?))\n"
";; CompilerException java.lang.Exception: Unable to construct gen at: [] for: clojure.core$even_QMARK_@188fc6fd\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:990
msgid ""
"In this case spec was not able to find a generator for the `even?` predicate. Most of the primitive generators in "
"spec are mapped to the common type predicates (strings, numbers, keywords, etc)."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:992
msgid ""
"However, spec is designed to support this case via `and` - the first predicate will determine the generator and "
"subsequent branches will act as filters by applying the predicate to the produced values (using test.check's `such-"
"that`)."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:994
msgid ""
"If we modify our predicate to use an `and` and a predicate with a mapped generator, the `even?` can be used as a "
"filter for generated values instead:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:999
#, no-wrap
msgid ""
"(gen/generate (s/gen (s/and int? even?)))\n"
";;=> -15161796\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1002
msgid ""
"We can use many predicates to further refine the generated values. For example, say we only wanted to generate "
"numbers that were positive multiples of 3:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1006
#, no-wrap
msgid "(defn divisible-by [n] #(zero? (mod % n)))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1011
#, no-wrap
msgid ""
"(gen/sample (s/gen (s/and int?\n"
"                     #(> % 0)\n"
"                     (divisible-by 3))))\n"
";;=> (3 9 1524 3 1836 6 3 3 927 15027)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1014
msgid ""
"However, it is possible to go too far with refinement and make something that fails to produce any values. The test."
"check https://clojure.github.io/test.check/clojure.test.check.generators.html#var-such-that[`such-that`] that "
"implements the refinement will throw an error if the refinement predicate cannot be resolved within a relatively "
"small number of attempts. For example, consider trying to generate strings that happen to contain the word \"hello\":"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1020
#, no-wrap
msgid ""
";; hello, are you the one I'm looking for?\n"
"(gen/sample (s/gen (s/and string? #(clojure.string/includes? % \"hello\"))))\n"
";; ExceptionInfo Couldn't satisfy such-that predicate after 100 tries.\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1023
msgid ""
"Given enough time (maybe a lot of time), the generator probably would come up with a string like this, but the "
"underlying `such-that` will make only 100 attempts to generate a value that passes the filter. This is a case where "
"you will need to step in and provide a custom generator."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1024
#, no-wrap
msgid "Custom Generators"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1027
msgid ""
"Building your own generator gives you the freedom to be either narrower and/or be more explicit about what values you "
"want to generate. Alternately, custom generators can be used in cases where conformant values can be generated more "
"efficiently than using a base predicate plus filtering. Spec does not trust custom generators and any values they "
"produce will also be checked by their associated spec to guarantee they pass conformance."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1029
msgid "There are three ways to build up custom generators - in decreasing order of preference:"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1031
msgid "Let spec create a generator based on a predicate/spec"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1032
msgid "Create your own generator from the tools in clojure.spec.gen.alpha"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1033
msgid ""
"Use test.check or other test.check compatible libraries (like https://github.com/gfredericks/test.chuck[test.chuck])"
msgstr ""

#. type: delimited block =
#: en/content/guides/spec.adoc:1037
msgid ""
"The last option requires a runtime dependency on test.check so the first two options are strongly preferred over "
"using test.check directly."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1040
msgid "First consider a spec with a predicate to specify keywords from a particular namespace:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1046
#, no-wrap
msgid ""
"(s/def ::kws (s/and keyword? #(= (namespace %) \"my.domain\")))\n"
"(s/valid? ::kws :my.domain/name) ;; true\n"
"(gen/sample (s/gen ::kws)) ;; unlikely we'll generate useful keywords this way\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1049
msgid ""
"The simplest way to start generating values for this spec is to have spec create a generator from a fixed set of "
"options. A set is a valid predicate spec so we can create one and ask for it's generator:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1055
#, no-wrap
msgid ""
"(def kw-gen (s/gen #{:my.domain/name :my.domain/occupation :my.domain/id}))\n"
"(gen/sample kw-gen 5)\n"
";;=> (:my.domain/occupation :my.domain/occupation :my.domain/name :my.domain/id :my.domain/name)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1058
msgid ""
"To redefine our spec using this custom generator, use https://clojure.github.io/clojure/branch-master/clojure.spec-"
"api.html#clojure.spec.gen/with-gen[`with-gen`] which takes a spec and a replacement generator:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1066
#, no-wrap
msgid ""
"(s/def ::kws (s/with-gen (s/and keyword? #(= (namespace %) \"my.domain\"))\n"
"               #(s/gen #{:my.domain/name :my.domain/occupation :my.domain/id})))\n"
"(s/valid? ::kws :my.domain/name)  ;; true\n"
"(gen/sample (s/gen ::kws))\n"
";;=> (:my.domain/occupation :my.domain/occupation :my.domain/name  ...)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1069
msgid ""
"Note that `with-gen` (and other places that take a custom generator) take a no-arg function that returns the "
"generator, allowing it to be lazily realized."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1071
msgid ""
"One downside to this approach is we are missing what property testing is really good at: automatically generating "
"data across a wide search space to find unexpected problems."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1073
msgid ""
"The clojure.spec.gen.alpha namespace has a number of functions for generator \"primitives\" as well as \"combinators"
"\" for combining them into more complicated generators."
msgstr ""

#. type: delimited block =
#: en/content/guides/spec.adoc:1077
msgid ""
"Nearly all of the functions in the clojure.spec.gen.alpha namespace are merely wrappers that dynamically load "
"functions of the same name in test.check. You should refer to the documentation for https://clojure.github.io/test."
"check/[test.check] for more details on how all of the clojure.spec.gen.alpha generator functions work."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1080
msgid ""
"In this case we want our keyword to have open names but fixed namespaces. There are many ways to accomplish this but "
"one of the simplest is to use https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec.gen/"
"fmap[`fmap`] to build up a keyword based on generated strings:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1086
#, no-wrap
msgid ""
"(def kw-gen-2 (gen/fmap #(keyword \"my.domain\" %) (gen/string-alphanumeric)))\n"
"(gen/sample kw-gen-2 5)\n"
";;=> (:my.domain/ :my.domain/ :my.domain/1 :my.domain/1O :my.domain/l9p2)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1089
msgid ""
"`gen/fmap` takes a function to apply and a generator. The function will be applied to each sample produced by the "
"generator allowing us to build one generator on another."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1091
msgid ""
"However, we can spot a problem in the example above - generators are often designed to return \"simpler\" values "
"first and any string-oriented generator will often return an empty string which is not a valid keyword. We can make a "
"slight adjustment to omit that particular value using https://clojure.github.io/clojure/branch-master/clojure.spec-"
"api.html#clojure.spec.gen/such-that[`such-that`] which lets us specify a filtering condition:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1099
#, no-wrap
msgid ""
"(def kw-gen-3 (gen/fmap #(keyword \"my.domain\" %)\n"
"               (gen/such-that #(not= % \"\")\n"
"                 (gen/string-alphanumeric))))\n"
"(gen/sample kw-gen-3 5)\n"
";;=> (:my.domain/O :my.domain/b :my.domain/ZH :my.domain/31 :my.domain/U)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1102
msgid "Returning to our \"hello\" example, we now have the tools to make that generator:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1111
#, no-wrap
msgid ""
"(s/def ::hello\n"
"  (s/with-gen #(clojure.string/includes? % \"hello\")\n"
"    #(gen/fmap (fn [[s1 s2]] (str s1 \"hello\" s2))\n"
"      (gen/tuple (gen/string-alphanumeric) (gen/string-alphanumeric)))))\n"
"(gen/sample (s/gen ::hello))\n"
";;=> (\"hello\" \"ehello3\" \"eShelloO1\" \"vhello31p\" \"hello\" \"1Xhellow\" \"S5bhello\" \"aRejhellorAJ7Yj\" \"3hellowPMDOgv7\" \"UhelloIx9E\")\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1114
msgid "Here we generate a tuple of a random prefix and random suffix strings, then insert \"hello\" bewteen them."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1115
#, no-wrap
msgid "Range Specs and Generators"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1118
msgid ""
"There are several cases where it's useful to spec (and generate) values in a range and spec provides helpers for "
"these cases."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1120
msgid ""
"For example, in the case of a range of integer values (for example, a bowling roll), use https://clojure.github.io/"
"clojure/branch-master/clojure.spec-api.html#clojure.spec.gen/int-in[`int-in`] to spec a range (end is exclusive):"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1126
#, no-wrap
msgid ""
"(s/def ::roll (s/int-in 0 11))\n"
"(gen/sample (s/gen ::roll))\n"
";;=> (1 0 0 3 1 7 10 1 5 0)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1129
msgid ""
"spec also includes https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec.gen/inst-"
"in[`inst-in`] for a range of instants:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1139
#, no-wrap
msgid ""
"(s/def ::the-aughts (s/inst-in #inst \"2000\" #inst \"2010\"))\n"
"(drop 50 (gen/sample (s/gen ::the-aughts) 55))\n"
";;=> (#inst\"2005-03-03T08:40:05.393-00:00\"\n"
";;    #inst\"2008-06-13T01:56:02.424-00:00\"\n"
";;    #inst\"2000-01-01T00:00:00.610-00:00\"\n"
";;    #inst\"2006-09-13T09:44:40.245-00:00\"\n"
";;    #inst\"2000-01-02T10:18:42.219-00:00\")\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1142
msgid "Due to the generator implementation, it takes a few samples to get \"interesting\" so I skipped ahead a bit."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1144
msgid ""
"Finally, https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec.gen/double-in[`double-"
"in`] has support for double ranges and special options for checking special double values like `NaN` (not a number), "
"`Infinity`, and `-Infinity`."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1154
#, no-wrap
msgid ""
"(s/def ::dubs (s/double-in :min -100.0 :max 100.0 :NaN? false :infinite? false))\n"
"(s/valid? ::dubs 2.9)\n"
";;=> true\n"
"(s/valid? ::dubs Double/POSITIVE_INFINITY)\n"
";;=> false\n"
"(gen/sample (s/gen ::dubs))\n"
";;=> (-1.0 -1.0 -1.5 1.25 -0.5 -1.0 -3.125 -1.5625 1.25 -0.390625)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1157
msgid ""
"To learn more about generators, read the test.check https://clojure.github.io/test.check/intro.html[tutorial] or "
"https://clojure.github.io/test.check/generator-examples.html[examples]. Do keep in mind that while clojure.spec.gen."
"alpha is a large subset of clojure.test.check.generators, not everything is included."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:1158
#, no-wrap
msgid "Instrumentation and Testing"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1161
msgid ""
"spec provides a set of development and testing functionality in the `clojure.spec.test.alpha` namespace, which we can "
"include with:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1165 en/content/guides/spec.adoc:1203
#, no-wrap
msgid "(require '[clojure.spec.test.alpha :as stest])\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1167 en/content/about/spec.adoc:100
#, no-wrap
msgid "Instrumentation"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1170
msgid ""
"Instrumentation validates that the `:args` spec is being invoked on instrumented functions and thus provides "
"validation for external uses of a function. Let's turn on instrumentation for our previously spec'ed `ranged-rand` "
"function:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1174
#, no-wrap
msgid "(stest/instrument `ranged-rand)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1177
msgid ""
"Instrument takes a fully-qualified symbol so we use `pass:[`]` here to resolve it in the context of the current "
"namespace. If the function is invoked with args that do not conform with the `:args` spec you will see an error like "
"this:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1188
#, no-wrap
msgid ""
"(ranged-rand 8 5)\n"
"CompilerException clojure.lang.ExceptionInfo: Call to #'spec.examples.guide/ranged-rand did not conform to spec:\n"
"val: {:start 8, :end 5} fails at: [:args] predicate: (< (:start %) (:end %))\n"
":clojure.spec.alpha/args  (8 5)\n"
":clojure.spec.alpha/failure  :instrument-check-failed\n"
" #:clojure.spec.alpha{:problems [{:path [:args], :pred (< (:start %) (:end %)), :val {:start 8, :end 5}, :via [], :in []}],\n"
"                      :args (8 5), \n"
"                      :failure :instrument-check-failed}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1191
msgid ""
"The error fails in the second args predicate that checks `(< start end)`. Note that the `:ret` and `:fn` specs are "
"not checked with instrumentation as validating the implementation should occur at testing time."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1193
msgid ""
"Instrumentation can be turned off using the complementary function `unstrument`. Instrumentation is likely to be "
"useful at both development time and during testing to discover errors in calling code. It is not recommended to use "
"instrumentation in production due to the overhead involved with checking args specs."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1194
#, no-wrap
msgid "Testing"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1197
msgid ""
"We mentioned earlier that `clojure.spec.test.alpha` provides tools for automatically testing functions. When "
"functions have specs, we can use https://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec."
"test/check[`check`], to automatically generate tests that check the function using the specs."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1199
msgid ""
"`check` will generate arguments based on the `:args` spec for a function, invoke the function, and check that the `:"
"ret` and `:fn` specs were satisfied."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1209
#, no-wrap
msgid ""
"(stest/check `ranged-rand)\n"
";;=> ({:spec #object[clojure.spec.alpha$fspec_impl$reify__13728 ...],\n"
";;     :clojure.spec.test.check/ret {:result true, :num-tests 1000, :seed 1466805740290},\n"
";;     :sym spec.examples.guide/ranged-rand,\n"
";;     :result true})\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1212
msgid ""
"`check` also takes a number of options that can be passed to test.check to influence the test run, as well as the "
"option to override generators for parts of the spec, by either name or path."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1214
msgid "Imagine instead that we made an error in the ranged-rand code and swapped start and end:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1221
#, no-wrap
msgid ""
"(defn ranged-rand  ;; BROKEN!\n"
"  \"Returns random int in range start <= rand < end\"\n"
"  [start end]\n"
"  (+ start (long (rand (- start end)))))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1224
msgid ""
"This broken function will still create random integers, just not in the expected range. Our `:fn` spec will detect "
"the problem when checking the var:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1243
#, no-wrap
msgid ""
"(stest/abbrev-result (first (stest/check `ranged-rand)))\n"
";;=> ({:spec (fspec\n"
";;            :args (and (cat :start int? :end int?) (fn* [p1__3468#] (< (:start p1__3468#) (:end p1__3468#))))\n"
";;            :ret int?\n"
";;            :fn (and\n"
";;                  (fn* [p1__3469#] (>= (:ret p1__3469#) (-> p1__3469# :args :start)))\n"
";;                  (fn* [p1__3470#] (< (:ret p1__3470#) (-> p1__3470# :args :end))))),\n"
";;     :sym spec.examples.guide/ranged-rand,\n"
";;     :result {:clojure.spec.alpha/problems [{:path [:fn],\n"
";;                                             :pred (>= (:ret %) (-> % :args :start)),\n"
";;                                             :val {:args {:start -3, :end 0}, :ret -5},\n"
";;                                             :via [],\n"
";;                                             :in []}],\n"
";;              :clojure.spec.test.alpha/args (-3 0),\n"
";;              :clojure.spec.test.alpha/val {:args {:start -3, :end 0}, :ret -5},\n"
";;              :clojure.spec.alpha/failure :test-failed}}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1246
msgid ""
"`check` has reported an error in the `:fn` spec. We can see the arguments passed were -3 and 0 and the return value "
"was -5, which is out of the expected range."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1248
msgid ""
"To test all of the spec'ed functions in a namespace (or multiple namespaces), use https://clojure.github.io/clojure/"
"branch-master/clojure.spec-api.html#clojure.spec.test/enumerate-namespace[`enumerate-namespace`] to generate the set "
"of symbols naming vars in the namespace:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1252
#, no-wrap
msgid "(-> (stest/enumerate-namespace 'user) stest/check)\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1255
msgid "And you can check all of the spec'ed functions by calling `stest/check` without any arguments."
msgstr ""

#. type: Title ===
#: en/content/guides/spec.adoc:1256
#, no-wrap
msgid "Combining `check` and `instrument`"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1259
msgid ""
"While both `instrument` (for enabling `:args` checking) and `check` (for generating tests of a function) are useful "
"tools, they can be combined to provide even deeper levels of test coverage."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1261
msgid ""
"`instrument` takes a number of options for changing the behavior of instrumented functions, including support for "
"swapping in alternate (narrower) specs, stubbing functions (by using the `:ret` spec to generate results), or "
"replacing functions with an alternate implementation."
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1263
msgid ""
"Consider the case where we have a low-level function that invokes a remote service and a higher-level function that "
"calls it."
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1267
#, no-wrap
msgid ";; code under test\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1271
#, no-wrap
msgid ""
"(defn invoke-service [service request]\n"
"  ;; invokes remote service\n"
"  )\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1275
#, no-wrap
msgid ""
"(defn run-query [service query]\n"
"  (let [{::keys [result error]} (invoke-service service {::query query})]\n"
"    (or result error)))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1278
msgid "We can spec these functions using the following specs:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1287
#, no-wrap
msgid ""
"(s/def ::query string?)\n"
"(s/def ::request (s/keys :req [::query]))\n"
"(s/def ::result (s/coll-of string? :gen-max 3))\n"
"(s/def ::error int?)\n"
"(s/def ::response (s/or :ok (s/keys :req [::result])\n"
"                    :err (s/keys :req [::error])))\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1291
#, no-wrap
msgid ""
"(s/fdef invoke-service\n"
"  :args (s/cat :service any? :request ::request)\n"
"  :ret ::response)\n"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1295
#, no-wrap
msgid ""
"(s/fdef run-query\n"
"  :args (s/cat :service any? :query string?)\n"
"  :ret (s/or :ok ::result :err ::error))\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1298
msgid ""
"And then we want to test the behavior of `run-query` while stubbing out `invoke-service` with `instrument` so that "
"the remote service is not invoked:"
msgstr ""

#. type: delimited block -
#: en/content/guides/spec.adoc:1309
#, no-wrap
msgid ""
"(stest/instrument `invoke-service {:stub #{`invoke-service}})\n"
";;=> [spec.examples.guide/invoke-service]\n"
"(invoke-service nil {::query \"test\"})\n"
";;=> #:spec.examples.guide{:error -11}\n"
"(invoke-service nil {::query \"test\"})\n"
";;=> #:spec.examples.guide{:result [\"kq0H4yv08pLl4QkVH8\" \"in6gH64gI0ARefv3k9Z5Fi23720gc\"]}\n"
"(stest/summarize-results (stest/check `run-query))\n"
";;=> {:total 1, :check-passed 1}\n"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1312
msgid ""
"The first call here instruments and stubs `invoke-service`. The second and third calls demonstrate that calls to "
"`invoke-service` now return generated results (rather than hitting a service). Finally, we can use `check` on the "
"higher level function to test that it behaves properly based on the generated stub results returned from `invoke-"
"service`."
msgstr ""

#. type: Title ==
#: en/content/guides/spec.adoc:1313
#, no-wrap
msgid "Wrapping Up"
msgstr ""

#. type: Plain text
#: en/content/guides/spec.adoc:1315
msgid ""
"In this guide we have covered most of the features for designing and using specs and generators. We expect to add "
"some more advanced generator techniques and help on testing in a future update."
msgstr ""
